 # if (xvalues.count(xval) != 0):
                #     # If the point is on input list, immigrate data.
                #     index = xvalues.index(xval)
                #     yval = yvalues[index]
                #     pointname = pointsInput[index].point_name
                #     # Create a point, if no name input, name = empty string so no errors
                #     newPoint = Waypoint(point=Vector3(x=xval, y=yval, z=0.0), 
                #                         heading= pointsInput[index].heading, 
                #                         max_vel= pointsInput[index].velocity, 
                #                         point_name= pointname if pointname is not None else "")
                #     prevVelocity = pointsInput[index].velocity
                # else:
                #     # If not on list, make a point
                #     yval = (float(cubicSpline(xval, *constants)) if not linear else float(linearSpline(xval, *constants)))
                #     newPoint = Waypoint(point=Vector3(x=xval, y=yval, z=0.0), 
                #                         heading= 0.0, # TODO Add heading enforcement
                #                         max_vel= prevVelocity + maxAccel*0.01,
                #                         point_name= "")
                #     prevVelocity = prevVelocity + maxAccel*0.01
        
                # # Regardless, append the point created to the list
                # pointsOutput.append(newPoint)


                # if point.point.x <= pointsInput[points].point.x:
                #     while nextxvalue < pointsInput[len(pointsInput)-1].point.x:
                #         currentxvalue = nextxvalue
                #         finalxvals.append(currentxvalue)
                #         nextxvalue = currentxvalue + previousVelocity*tDelta + maxAccel*tDelta^2
                #         if index+1 < len(pointsInput)-1:
                #             if currentxvalue >= pointsInput[index+1].point.x:
                #                 previousVelocity = pointsInput[index+1].velocity
                #                 index = index+1
                #     finalxvals.append(pointsInput[len(pointsInput)-1].point.x)


            # for xvalue in finalxvals:
            #     if point.velocity >= prevPoint.velocity:
            #         # If increasing in velocity over the segment
            #         prevVelocity = prevPoint.velocity

            for waypoint in pointsInput: # for every point in the list of input points
                if pointsInput.index(waypoint) == 0: continue
                prevWaypoint = pointsInput[pointsInput.index(waypoint)-1]
                segStartTime = timeParameterizedTimes[timeParameterizedPoints.index(prevWaypoint)]
                # If segment is supposed to be deccelerating, negate the acceleration
                #segmentAccel = (-maxAccel if waypoint.velocity < prevWaypoint.velocity else maxAccel)
                # If heading is rotating left (negative) then negate max angular velocity
                segmentAngVel = -maxAngularVelocity if abs(prevWaypoint.heading - waypoint.heading) > 180 else maxAngularVelocity

                nextPoint = prevWaypoint
                conditional = ""
                decreasing = False
                if prevWaypoint.point.x > waypoint.point.x: # X decreasing over segment
                    conditional = "nextPoint.point.x > waypoint.point.x" 
                    decreasing = True
                elif prevWaypoint.point.x < waypoint.point.x: conditional = "nextPoint.point.x < waypoint.point.x" # X increasing over segment
                else: # X staying the same over segment, use ys
                    if prevWaypoint.point.y > waypoint.point.y: # Y decreasing over segment
                        conditional = "nextPoint.point.y > waypoint.point.y"
                        decreasing = True 
                    elif prevWaypoint.point.y < waypoint.point.y: conditional = "nextPoint.point.y < waypoint.point.y" # Y increasing over segment
                    else: conditional = "False" # They're the same damn point somehow, idk how the fuck you got that one
        
                print(conditional)
                if not decreasing:
                    while eval(conditional) and currentTime < 30:
                            #keep making waypoints every 0,01 seconds until done 
                            xval = prevWaypoint.point.x + prevWaypoint.velocity*tDelta + maxAccel*(tDelta**2) # x val calculated from tdelta
                            yval = (float(cubicSpline(xval, *constants)) if not linear else float(linearSpline(xval, *constants))) # y val calculated from curve fitted earlier 
                            print("xval: " + str(xval) + "yval: " + str(yval))
                            velocityVal = math.sqrt(previousVelocity**2 + 2*segmentAccel*(self.findDistance(prevWaypoint, xval, yval)))
                            headingVal = prevWaypoint.heading + (segmentAngVel * (currentTime-segStartTime)) # Heading Calculation using angular velocity
                            if headingVal < 0: headingVal = 360+headingVal # make sure negative headings don't happen
                            if segmentAngVel < 0: headingVal = (headingVal if headingVal < waypoint.heading else waypoint.heading) # Turning Left Overshoot Check
                            else: headingVal = (headingVal if headingVal > waypoint.heading else waypoint.heading) # Turning Right Overshoot Check
                            nextPoint = Waypoint(point=Vector3(x= xval, y=yval, z=0.0), 
                                                heading= headingVal, # 
                                                velocity= (velocityVal if velocityVal < maxVelocity else maxVelocity),
                                                point_name= "")
                            previousVelocity = velocityVal
                            timeParameterizedPoints.append(nextPoint)
                            timeParameterizedTimes.append(currentTime)
                            currentTime = currentTime + 0.01
                            prevWaypoint = nextPoint
                else:
                    while eval(conditional) and currentTime < 30:
                            #keep making waypoints every 0,01 seconds until done 
                            xval = prevWaypoint.point.x - prevWaypoint.velocity*tDelta + maxAccel*(tDelta**2) # x val calculated from tdelta
                            yval = (float(cubicSpline(xval, *constants)) if not linear else float(linearSpline(xval, *constants))) # y val calculated from curve fitted earlier 
                            print("xval: " + str(xval) + "yval: " + str(yval))
                            velocityVal = math.sqrt(previousVelocity**2 + 2*segmentAccel*(self.findDistance(prevWaypoint, xval, yval)))
                            headingVal = prevWaypoint.heading + (segmentAngVel * (currentTime-segStartTime)) # Heading Calculation using angular velocity
                            if headingVal < 0: headingVal = 360+headingVal # make sure negative headings don't happen
                            if segmentAngVel < 0: headingVal = (headingVal if headingVal < waypoint.heading else waypoint.heading) # Turning Left Overshoot Check
                            else: headingVal = (headingVal if headingVal > waypoint.heading else waypoint.heading) # Turning Right Overshoot Check
                            nextPoint = Waypoint(point=Vector3(x= xval, y=yval, z=0.0), 
                                                heading= headingVal, # 
                                                velocity= (velocityVal if velocityVal < maxVelocity else maxVelocity),
                                                point_name= "")
                            previousVelocity = velocityVal
                            timeParameterizedPoints.append(nextPoint)
                            timeParameterizedTimes.append(currentTime)
                            currentTime = currentTime + 0.01
                            prevWaypoint = nextPoint

               
                # Parameterize last point (also end waypoint)
                
                timeParameterizedPoints.append(waypoint)
                timeParameterizedTimes.append(currentTime)
                currentTime = currentTime + 0.01
